{
    "contents" : "# =============================================================================\n# Utilities for Epiconcept\n# =============================================================================\nrequire(ggplot2)\nrequire(plyr)\nrequire(grid)\nrequire(gridExtra)\nrequire(xtable);\nlibrary(methods)\nrequire(boot)\nrequire(jsonlite)\nlibrary(fBasics)\n\nsetGeneric(\"Plot\", function(this, ...) {\n  return(standardGeneric(\"Plot\"))\n})\n\nsetGeneric(\"ec.plot\", function(this, ...) {\n  return(standardGeneric(\"ec.plot\"))\n})\n\nsetGeneric(\"Close\", function(this) {\n  return(standardGeneric(\"Close\"))\n})\n\nec.use <- function(df = \"raw\", extension=\"csv\") \n{\n  if (extension == 'df') {\n    data(list=c(as.name(df)), envir=.GlobalEnv);\n    assign('GDS', eval(parse(text=df)), envir=.GlobalEnv);\n    rm(list=c(df), envir=.GlobalEnv);\n    x <- gc();\n  }\n  else {\n    rds = paste(df,\"rds\", sep=\".\");\n    csv = paste(df,extension, sep=\".\");\n    \n    if (file.exists(rds)) {\n      #GDS <<- readRDS(rds);\n      assign('GDS', readRDS(rds), envir=.GlobalEnv);\n    }\n    \n    else if (file.exists(csv)) {\n      assign('GDS', read.csv2(csv, na.strings = \"\"), envir=.GlobalEnv,  colClasses=\"factor\");\n      ec.Save(\"RAW\");\n    }\n  }\n}\n\n\nVAL <- function(varname)\n{\n  #GDS = get(\"GDS\", envir=.GlobalEnv);\n  return(GDS[,varname]);\n}\n\nfreq <- function(x, by=NULL, where=NULL)\n{\n  if (is.character(by)) {\n    if (is.vector(where)) {\n      #R = data.frame(table(GDS[where, x], GDS[where, by]));\n      R = table(GDS[where, x], GDS[where, by]);\n      return(R)\n      names(R) <- c(x, by, \"Freq\");\n      return(R);\n    }\n    #R = data.frame(table(VAL(x), VAL(by)));\n    R = table(VAL(x), VAL(by));\n    #names(R) <- c(x, by, \"Freq\");\n    return(R);\n  }\n  if (is.vector(where)) {\n    R = data.frame(table(GDS[where, x]));\n    names(R) <- c(x, \"Freq\");\n    return(R);\n  }\n  R = data.frame(table(GDS[, x]));\n  names(R) <- c(x, \"Freq\");\n  return(R);\n}\n\nec.max <- function(x)\n{\n  C = class(GDS[, x]);\n  if (C == \"factor\") {\n    return(c(\"\", \"\", \"\", \"\"));\n  }\n\n  return(max(GDS[, x], na.rm=TRUE));\n}\n\nec.min <- function(x)\n{\n  C = class(GDS[, x]);\n  if (C == \"factor\") {\n    return(c(\"\", \"\", \"\", \"\"));\n  }\n\n  return(min(GDS[, x], na.rm=TRUE));\n}\n\nec.mean <- function(x)\n{\n  return(sprintf(\"%5.5f\", mean(GDS[, x], na.rm=TRUE)));\n}\n\nec.median <- function(x)\n{\n  return(sprintf(\"%5.5f\",median(GDS[, x], na.rm=TRUE)));\n}\n\nec.kurtosis <- function(x)\n{\n  if (class(GDS[, x]) == \"Date\") {\n    return(\"\");\n  }\n\n  K <- kurtosis(GDS[, x], method=\"moment\", na.rm=TRUE);\n  return(sprintf(\"%5.5f\", K[1]));\n}\n\ngdsQuantile <- function(x)\n{\n  C = class(GDS[, x]);\n  if (C == \"Date\" | C == \"Factor\") {\n    return(c(\"\", \"\", \"\", \"\"));\n  }\n  \n  Q <- quantile(GDS[, x], na.rm=TRUE);\n  return(as.vector(Q));\n}\n\nec.sd <- function(x)\n{\n  SD = sd(GDS[, x], na.rm=TRUE)\n  return(sprintf(\"%5.5f\", SD));\n}\n\nec.skewness <- function(x)\n{\n  if (class(GDS[, x]) == \"Date\") {\n    return(\"\");\n  }\n  S <- skewness(GDS[, x], na.rm=TRUE, method=\"moment\");\n  return(sprintf(\"%5.5f\", S[1]));\n}\n\nec.variance <- function(x)\n{\n  return(sprintf(\"%5.5f\", var(GDS[, x], na.rm=TRUE)));\n}\n\nec.proportion <- function(c)\n{\n#  library(boot);\n  set.seed(123)\n  x<-GDS[,c]\n  N_ = nrow(GDS);\n  \n  myprop<-function(x,i){\n    sum(x[i]==0)/length(x)\n  }\n  \n  B <- boot(x, myprop, 100);\n  SD_ = sprintf(\"%5.6f\", sd(B$t));\n  T = table(x);\n  NAMES_ = names(T)\n  M1_ = T[1];\n  M2_ = T[2];\n  NDF = c(c, \"Obs.\",\"Proportion\", \"Std. Err.\", \"95% CI.Low\", \"95% CI.Low\");\n\n  P = prop.test(M1_, N_, conf.level=0.95);\n  PE1_ = P$estimate;\n  CI1_LOW = P$conf.int[1];\n  CI1_HIG = P$conf.int[2];\n  \n  P = prop.test(M2_, N_, conf.level=0.95);\n  PE2_ = P$estimate;\n  CI2_LOW = P$conf.int[1];\n  CI2_HIG = P$conf.int[2];\n  \n  R1 = c(NAMES_[1], M1_, PE1_, SD_, CI1_LOW, CI1_HIG);\n  R2 = c(NAMES_[2], M2_, PE2_, SD_, CI2_LOW, CI2_HIG);\n  \n#  DF = data.frame(rbind(\"1\"=R1, \"2\"=R2));\n  DF = data.frame(cbind(NAMES_));\n  DF = cbind(DF, as.numeric(c(M1_,M2_)));\n  DF = cbind(DF, as.numeric(c(PE1_,PE2_)));\n  DF = cbind(DF, as.numeric(c(SD_,SD_)));\n  DF = cbind(DF, as.numeric(c(CI1_LOW,CI2_LOW)));\n  DF = cbind(DF, as.numeric(c(CI1_HIG,CI2_HIG)));\n  names(DF) <- NDF;\n  digits =  c(0,0,0,4,4,5,5);\n  align  =  c(\"l\",\"c\",\"c\",\"r\",\"r\",\"r\",\"r\");\n  odf <- xtable(DF, digits=digits, align=align);\n  print(odf, type = \"html\", include.rownames = F);\n}\n\n\n\ncomputeRiskCI <- function(risk, X1, N1, X2, N2)\n{\n  A = ((N1-X1)/X1)/N1;\n  B = ((N2-X2)/X2)/N2;\n  R1 = log(risk) + (1.96*sqrt(A + B));\n  R2 = log(risk) - (1.96*sqrt(A + B));\n  E1 = exp(R1);\n  E2 = exp(R2);\n  \n  return(c(E2, E1));\n}\n\nrr <- function(Tb)\n{\n  TE = Tb[2,1]+Tb[2,2];\n  TU = Tb[1,1]+Tb[1,2];\n  CE = Tb[2,2];\n  CU = Tb[1,2];\n  TO = TE + TU;\n  \n  RE = CE / TE;\n  RU = CU / TU;\n  \n  RR  = RE/RU;\n  CI = computeRiskCI(RR, CE, TE, CU, TU);\n  RRCIL = CI[1];\n  RRCIH = CI[2];\n  \n  return(c(RR, RRCIL, RRCIH))\n}\n\n# ========================================================================\n# CASES CONTROLS STUDY\n# ========================================================================\n# Comppute ODDS ratio\n# -------------------\nor <- function(T)\n{\n  O <- (T[2,2]/T[2,1]) / (T[1,2]/T[1,1]);\n  x <- matrix(T, 2, byrow = TRUE);\n  R <- fisher.test(x);\n  CIL <- R$conf.int[1];\n  CIH <- R$conf.int[2];\n  return(c(O, CIL, CIH));\n}\n\nCC_AR <- function(C)\n{\n  T = epi.2by2(dat=C, method=\"case.control\");\n  S <- summary(T);\n  return(c(S$AFest[1], S$AFest[2], S$AFest[3]));\n}\n\nCC_PAR <- function(C)\n{\n  T = epi.2by2(dat=C, method=\"case.control\", outcome=\"as.columns\");\n  S <- summary(T);\n  return(S$AFp[1]);\n}\n\nCC_STATS <- function(C)\n{\n  T = epi.2by2(dat=C, method=\"case.control\", outcome=\"as.columns\", homogeneity=\"woolf\");\n  S <- summary(T);\n  return(S);\n}\n\ncomputeOddsRatioCI <- function(O, a,b,c,d)\n{\n  LNO = log(O);\n  R1 = sqrt((1/a)+(1/b)+(1/c)+(1/d));\n  CIL = exp(LNO - 1.96 * R1);\n  CIH = exp(LNO + 1.96 * R1);\n  return(c(CIL, CIH));\n}\n\ncomputeExactORCI <- function(a,b,c,d)\n{\n  x <- matrix(c(a, b, c, d), 2, byrow = TRUE);\n  R <- fisher.test(x);\n  CIL <- R$conf.int[1];\n  CIH <- R$conf.int[2];\n  return(c(CIL, CIH, R$p.value));\n}\n\ncomputeDiffRiskCI <- function(RE, RU, NE, NU)\n{\n  A = RE - RU;\n  B = (RE * (1-RE))/NE;\n  C = (RU * (1-RU))/NU;\n  D = 1.96*sqrt(B + C);\n  R1 = A + D;\n  R2 = A - D;\n  \n  return(c(R2, R1));\n}\n\nCMHrr <- function(A, B)\n{\n  # Stratum 1 =====================\n  Ce1 = A[2,2]    ; # Cases exposed\n  Cu1 = A[1,2]    ; # Cases unexposed\n  He1 = A[2,1]    ; # Healthy exposed\n  Hu1 = A[1,1]    ; # Healthy unexposed\n\n  Te1 = Ce1 + He1 ; # Total exposed\n  Tu1 = Cu1 + Hu1 ; # Total unexposed\n  T1  = Te1 + Tu1 ; # Total strate 1\n  H1  = Hu1 + He1 ; # Total healthy\n  C1  = Cu1 + Ce1 ; # Total cases\n  \n  # Stratum 2 =====================\n  Ce2 = B[2,2]    ; # Cases exposed\n  Cu2 = B[1,2]    ; # Cases unexposed\n  He2 = B[2,1]    ; # Healthy exposed\n  Hu2 = B[1,1]    ; # Healthy unexposed\n\n  Te2 = Ce2 + He2 ; # Total exposed\n  Tu2 = Cu2 + Hu2 ; # Total unexposed\n  T2  = Te2 + Tu2 ; # Total strate 2\n  H2  = Hu2 + He2 ; # Total healthy\n  C2  = Cu2 + Ce2 ; # Total cases\n  \n  \n\n  R1 = ((Ce1 * Tu1) / T1) + ((Ce2 * Tu2) / T2);\n  R2 = ((Cu1 * Te1) / T1) + ((Cu2 * Te2) / T2);\n  rrmh = R1 / R2;\n\n  R3 = ((C1*Te1*Tu1) - (Ce1*Cu1*T1)) / T1^2;\n  R4 = ((C2*Te2*Tu2) - (Ce2*Cu2*T2)) / T2^2; \n  R5 = R3 + R4;\n  R6 = R5 / (R1 * R2);\n  R7 = sqrt(R6);\n  \n  L = log(rrmh) - (1.96 * R7);\n  H = log(rrmh) + (1.96 * R7);\n  \n  CIL = exp(L);\n  CIH = exp(H);\n  \n  return(c(rrmh, CIL, CIH));\n}\n\nMH_HomogeneityTest <- function(mht)\n{\n  T = epi.2by2(dat=mht, homogeneity=\"breslow.day\");\n  S <- summary(T);\n  return(c(S$RR.homog[1], S$RR.homog[3]));\n}\n\ncomputeKHI2 <- function(A, B, C, D)\n{\n  t <- chisq.test(matrix(c(A,B,C,D),ncol=2), correct=FALSE);\n  return(c(t$statistic, t$p.value));\n}\n\n\n\n\n# =============================================================================\n# Age functions\n# -----------------------------------------------------------------------------\n\n.getAge <- function(X, Y, unit=\"year\")\n{\n  if (unit == \"year\") {\n    return(as.integer(floor((Y - X) / 365.25)));\n  }\n  if (unit == \"month\") {\n    return(as.integer(floor((Y - X) / 30.437)));\n  }\n  if (unit == \"week\") {\n    return(as.integer(floor((Y - X) / 7)));\n  }\n  if (unit == \"day\") {\n    return (as.integer(Y - X));\n  }\n  stop(\"Bad period for addAgeVar!\")\n}\n\ngdsAddAgeVar <- function(varname, birthdate, onsetdate, unit=\"year\")\n{\n  X <- as.Date(GDS[,birthdate]);\n  if (onsetdate %in% colnames(GDS)) {\n    Y = as.Date(GDS[,onsetdate]);\n  }\n  else {\n    Y = as.Date(onsetdate)\n  }\n  X_AGE <- .getAge(X, Y, unit);\n  GDS <<- cbind(GDS, X_AGE);\n  gdsRenameCol(\"X_AGE\", varname);\n  \n}\n\n# -----------------------------------------------------------------------------\ncreateAgeScale  <- function(x, lower = 0, upper=100, by = 10, sep = \"-\", above.char = \"+\") {\n  \n  if (by == 1) {\n    labs <- c(seq(lower, upper, by = by))\n  }\n  else {\n    labs <- c(paste(seq(lower, upper - by, by = by),\n                    seq(lower + by - 1, upper - 1, by = by),\n                    sep = sep),\n              paste(upper, above.char, sep = \"\"))\n  }\n  cut(floor(x), breaks = c(seq(lower, upper, by = by), Inf),\n      right = FALSE, labels = labs)\n}\n\ntoFactor <- function(column, cut=3)\n{\n  R <- cut(GDS[,column], breaks = cut);\n  cmd = sprintf(\"transform(GDS, %s = R)\", column);\n  return (eval(parse(text = cmd)));\n}\n\n\nprintHTML <- function(x, ..., digits = 0, include.rownames = TRUE, \n                       header=names(x)){\n  # print html table with customized header, \n  # without permanently changing column names of the dataframe\n  origHeader <- names(x)\n  names(x) <- header\n  print(xtable(x, digits = digits, ...), \n        type = 'html', include.rownames = include.rownames)\n  names(x) <- origHeader\n}\n\n# -----------------------------------------------------------------------------\ndeviceOn <- function(name, format=\"png\", width=700, heigth=0)\n{\n  W = width / 90;\n  print(W);\n  fname <- paste(name, format, sep=\".\");\n  if (format == \"svg\") {\n    svg(filename=fname, width=W);\n  }\n  else if (format == \"png\") {\n    png(filename=fname, width=W);\n  }\n  else if (format == \"jpeg\") {\n    jpeg(filename=fname, width=W);\n  }\n  else if (format == \"pdf\") {\n    pdf(filename=fname, width=W);\n  }\n}\n\n\ngetDataset <- function(csvname=\"DATA\", extension=\"csv\")\n{\n  rda = paste(csvname,\"Rdata\", sep=\".\");\n  csv = paste(csvname,extension, sep=\".\");\n  \n  if (file.exists(rda)) {\n    GDS <<- readRDS(rda);\n    #attach(GDS);\n    return(TRUE);\n  }\n  \n  if (file.exists(csv)) {\n    GDS <<- read.csv(csv, na.strings = \"\");\n    #attach(GDS);\n    return(TRUE);\n  }\n  \n  msg <- sprintf(\"File [%s] not found in current directory!\", csv);\n  stop(msg);\n}\n\n\n\n# x <- matrix(c(158, 27, 7,94), 2, byrow = TRUE)\n#epi.2by2(dat=mht1, method=\"cohort.count\", conf.level = 0.95, units = 100, homogeneity = \"breslow.day\",outcome = \"as.columns\")\n#mhor(GDS$ill, GDS$wmousse, GDS$tira)\n\n",
    "created" : 1424192864418.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2940146815",
    "id" : "6CC060E7",
    "lastKnownWriteTime" : 1424192959,
    "path" : "~/R/Epiconcepts/R/01_EpiFuns.R",
    "project_path" : "R/01_EpiFuns.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}